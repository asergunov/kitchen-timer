# external_components:
#   - source: "github://asergunov/esphome_esphome@i2s_pdm"
#     components:
#       - i2s_audio
#       - i2s_audio/speaker
#     refresh: 0s

substitutions:
  display_clk_pin: "9"
  display_dio_pin: "10"
  power_sawing_pin: "8"
  active_buzzer_pin: "7"
  passive_buzzer_pin: "6"
  rotary_encoder_a_pin: "3"
  rotary_encoder_b_pin: "4"
  rotary_encoder_button_pin: "2"
  battery_voltage_pin: "1"
  charging_pin: "5"
  fully_charged_pin: "0"

esphome:
  name: kitchen-timer
  friendly_name: kitchen_timer
  # libraries:
  #   - esp_pm
  # includes:
  #   - kitchen-timer.h
  platformio_options:
    board_build.f_cpu: 80000000L
    lib_ldf_mode: "chain+"
  on_boot:
    then:
      - deep_sleep.prevent: deep_sleep_component

globals:
  - id: menu_active
    type: bool
    initial_value: "false"
  - id: enable_sleeping
    type: bool
    initial_value: "false"

  # on_boot:
  #   priority: 1000.0
  #   then:
  #     - lambda: |
  #         esp_pm_config_esp32c3_t configure = {
  #           .max_freq_mhz = 80, // 160,
  #           .min_freq_mhz = 80,
  #           .light_sleep_enable = false
  #         };
  #         ESP_ERROR_CHECK(esp_pm_configure(&configure));

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino
  # framework:
  #   type: esp-idf
  #   version: recommended
  #   sdkconfig_options:
  #     # COMPILER_OPTIMIZATION_SIZE: y
  #     CONFIG_COMPILER_OPTIMIZATION_PERF: y
  #     CONFIG_PM_ENABLE: y
  #     CONFIG_FREERTOS_USE_TICKLESS_IDLE: y

# Enable logging
logger:
  level: WARN

# debug:
#   update_interval: 10s

# Enable Home Assistant API
api:
  encryption:
    key: !secret kitchen_timer.api.encryption

ota:
  password: !secret kitchen_timer.ota.password
  on_begin:
    then:
      - switch.turn_off: power_saving
  on_error:
    then:
      - switch.turn_on: power_saving
  on_progress:
    then:
      - lambda: |
          id(tm1637_display).printf("%2.1f%", x);

deep_sleep:
  id: deep_sleep_component
  run_duration: 1000ms
  sleep_duration: 9000ms

wifi:
  id: wifi_component
  # power_save_mode: HIGH
  # enable_on_boot: False
  # fast_connect: True
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
    # - ssid: !secret parents.wifi_ssid
    #   password: !secret parents.wifi_password

#   # Enable fallback hotspot (captive portal) in case wifi connection fails
#   ap:
#     ssid: "Kitchen-Timer Fallback Hotspot"
#     password: "yOuGK5OiGnhg"

# captive_portal:

web_server:
  port: 80

# lcd_menu:
#   items:
#     - type: label
#       text: 'Label'
#     - type: back
#       text: 'Back'

time:
  - platform: sntp
    id: sntp_time

switch:
  - platform: gpio
    id: power_saving
    restore_mode: ALWAYS_ON
    name: Power Saving
    pin:
      number: ${power_sawing_pin}
      inverted: True
  - platform: template
    optimistic: True
    name: Flip display
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - lambda: |
            id(tm1637_display).set_inverted(true);
    on_turn_off:
      then:
        - lambda: |
            id(tm1637_display).set_inverted(false);
  - platform: template
    name: Auto Brightness
    id: auto_brightness_switch
    optimistic: True
    restore_mode: RESTORE_DEFAULT_ON

output:
  - platform: ledc
    ######################################################
    # One buzzer leg connected to GPIO12, the other to GND
    ######################################################
    pin: ${active_buzzer_pin}
    id: buzzer
  - platform: ledc
    id: rtttl_out
    pin: ${passive_buzzer_pin}

rtttl:
  output: rtttl_out
  id: my_rtttl
  gain: 50%

i2c:
  - sda: 20
    scl: 21

script:
  - id: rotary_click
    mode: queued
    then:
      - output.set_level:
          id: rtttl_out
          level: "100%"
      - output.turn_on: rtttl_out
      - delay: 1ms
      - output.turn_off: rtttl_out
      - delay: 1ms

sensor:
  - platform: rotary_encoder
    id: encoder
    name: Encoder
    pin_a:
      inverted: True
      number: ${rotary_encoder_a_pin}
    pin_b:
      inverted: True
      number: ${rotary_encoder_b_pin}
    on_value:
      then:
        - lambda: |
            if(id(menu_active)) {
              id(enable_sleeping) = !id(enable_sleeping);
              if(enable_sleeping) {
              //   id(wifi_component).disable();
                id(deep_sleep_component).allow_deep_sleep();
              } else {
              //   id(wifi_component).enable();
              //   id(wifi_component).retry_connect();
                id(deep_sleep_component).prevent_deep_sleep();
              }

              
              id(tm1637_display).update();
            }
        - script.execute: rotary_click

  - platform: veml7700
    id: light_sensor
    address: 0x10
    update_interval: 0.1s

    # short variant of sensor definition:
    ambient_light:
      id: ambient_light_sensor_fast
      name: Ambient Light Sensor Fast
      internal: True

    infrared:
      name: Infrared light
      filters:
        - throttle: 5s
    full_spectrum:
      name: Full spectrum light
      filters:
        - throttle: 5s

  - platform: copy
    name: "Ambient light"
    source_id: ambient_light_sensor_fast
    filters:
      - throttle: 5s

  - platform: copy
    source_id: ambient_light_sensor_fast
    id: desired_display_intencity
    internal: True
    filters:
      - calibrate_linear:
          method: exact
          datapoints:
            - 0 -> 0.
            - 10 -> 0.
            - 80 -> 1.
            - 140 -> 2.
            - 300 -> 3.
            - 2000 -> 7.
      - lambda: "return ceil(x);"
      - clamp:
          max_value: 7
          min_value: 0
      - delta: 90%

    on_value:
      then:
        - if:
            condition:
              - switch.is_on: auto_brightness_switch
            then:
              - lambda: |
                  id(tm1637_display).set_intensity(x);
                  id(tm1637_display).update();

  - platform: adc
    pin: ${battery_voltage_pin}
    attenuation: 11db
    accuracy_decimals: 4
    update_interval: 1s
    id: battery_voltage_unfiltrered
    name: Devider Voltage Unfiltered
    entity_category: diagnostic
    internal: True
    filters:
      - lambda: |
          auto value = x*1.89764693-0.09737394839;
          // if(id(charging_sensor).state)
          //   value -= 0.15;
          return value;
  - platform: copy
    source_id: battery_voltage_unfiltrered
    id: battery_voltage
    name: Battery Voltage
    accuracy_decimals: 4
    entity_category: diagnostic
    filters:
      - exponential_moving_average:
          alpha: 0.1
          send_every: 5
  - platform: copy
    source_id: battery_voltage
    name: Battery
    device_class: battery
    unit_of_measurement: "%"
    filters:
      # - lambda: |
      #     // see https://electronics.stackexchange.com/a/551667
      #     return 123.0 * (1.0 - 1.0/pow(1. + pow(x/3.7, 80.), 0.165));
      - calibrate_linear:
          method: exact
          datapoints:
            - 2.44 -> 0.0
            - 2.45 -> 0.01
            - 2.48 -> 0.02
            - 2.54 -> 0.06
            - 2.65 -> 0.11
            - 2.75 -> 0.18
            - 2.86 -> 0.31
            - 2.975 -> 0.6
            - 3.023 -> 0.79
            - 3.123 -> 1.29
            - 3.25 -> 2.26
            - 3.372 -> 3.87
            - 3.439 -> 5.44
            - 3.462 -> 7.01
            - 3.833 -> 39.42
            - 3.922 -> 57.1
            - 4.032 -> 72.4
            - 4.153 -> 97.53
            - 4.2 -> 100.
binary_sensor:
  - platform: gpio
    id: encoder_button
    name: Button
    pin:
      number: ${rotary_encoder_button_pin}
      inverted: True
    on_click:
      then:
        - lambda: |
            id(menu_active) = !id(menu_active);
            id(tm1637_display).update();
  - platform: gpio
    name: Charging
    id: charging_sensor
    pin:
      number: ${charging_pin}
      inverted: True
      mode:
        input: True
        pullup: True
  - platform: gpio
    name: Fully charged
    pin:
      number: ${fully_charged_pin}
      inverted: True
      mode:
        input: True
        pullup: True

text:
  - platform: template
    name: Set rtttl
    id: rtttl_text
    optimistic: true
    mode: text
    restore_value: True

button:
  - platform: restart
    name: Restart device
    entity_category: config
  - platform: template
    name: rtttl
    on_press:
      then:
        # 'siren:d=8,o=5,b=100:d,e,d,e,d,e,d,e'
        - rtttl.play: !lambda |
            return id(rtttl_text).state;

  - platform: template
    name: Buzz
    on_press:
      then:
        - output.turn_on: buzzer
        - output.set_level:
            id: buzzer
            level: "80%"
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "50Hz"
        - delay: 0.3s
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "200Hz"
        - delay: 0.3s
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "500Hz"
        - delay: 0.3s
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "1000Hz"
        - delay: 0.3s
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "2000Hz"
        - delay: 0.3s
        - output.ledc.set_frequency:
            id: buzzer
            frequency: "5000Hz"
        - delay: 0.3s
        - output.turn_off: buzzer

number:
  - platform: template
    name: Display intensity
    max_value: 7
    min_value: 0
    step: 1
    optimistic: True
    on_value:
      then:
        - lambda: id(tm1637_display).set_intensity(x);

display:
  platform: tm1637
  id: tm1637_display
  clk_pin: ${display_clk_pin}
  dio_pin: ${display_dio_pin}
  inverted: false
  length: 4
  update_interval: 500ms
  intensity: 7
  lambda: |-
    if(id(menu_active)) {
      it.print(0, id(enable_sleeping) ? "Wb.OF" : "Wb.ON");
      return;
    }
    static int i = 0;
    i++;
    if ((i % 2) == 0)
      it.strftime("%H.%M", id(sntp_time).now());
    else {
      it.strftime("%H%M", id(sntp_time).now());
      // ESP_ERROR_CHECK(esp_sleep_enable_timer_wakeup(5000*1000));
      // ESP_ERROR_CHECK(esp_sleep_enable_gpio_wakeup());
      // App.run_safe_shutdown_hooks();
      // adc_power_off();
      // ESP_ERROR_CHECK(esp_light_sleep_start());
    }


    // id(deep_sleep_component).allow_deep_sleep();

    // id(tm1637_display).update();

    // id(deep_sleep_component).set_sleep_duration(500);
    // id(deep_sleep_component).begin_sleep(false);

    if(id(enable_sleeping)) {
      // App.run_safe_shutdown_hooks();
      // for(const auto& gpio: std::initializer_list<gpio_num_t>{ GPIO_NUM_10, GPIO_NUM_21, GPIO_NUM_20 }) {
      //  ESP_ERROR_CHECK(gpio_wakeup_enable(gpio, GPIO_INTR_LOW_LEVEL));
      //}
      //ESP_ERROR_CHECK(esp_sleep_enable_timer_wakeup(60*1000*1000));
      //ESP_ERROR_CHECK(esp_sleep_enable_gpio_wakeup());
      //ESP_ERROR_CHECK(esp_light_sleep_start());

    }
